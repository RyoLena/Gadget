# 跳表(SkipList)技术文档

## 基本概念
跳表是一种类似"多层电梯"的数据结构：
- 底层是完整链表（包含所有元素）
- 上层是快速通道（间隔跳跃元素）
- 查找时从高层快速定位，逐步降层精确查找

## 数据结构组成
```go
type SkipList[T any] struct {
    header  *skipListNode[T]  // 头节点（哨兵）
    level   int               // 当前最高层数 
    compare Comparator[T]     // 元素比较器
    size    int               // 元素总数
}
```

## 核心方法速查表
| 方法 | 功能 | 时间复杂度 |
|------|------|-----------|
| Insert() | 插入元素 | O(log n) |
| Search() | 查找元素 | O(log n) |
| DeleteElement() | 删除元素 | O(log n) |
| Get() | 按索引获取 | O(n) |
| Peek() | 查看首元素 | O(1) |

## 关键实现原理

### 1. 层级随机生成（电梯建造原理）
```go
func (sl *SkipList[T]) randomLevel() int {
    // 类似抛硬币：25%概率增加一层
    // 最大层数限制为32层
}
```
- 新节点层数随机决定（平均分布）
- 高层的节点形成快速通道

### 2. 插入过程图解
```
Level 3: Head -> 15
Level 2: Head -> 9 -> 15
Level 1: Head -> 3 -> 9 -> 15 -> 27
Level 0: Head -> 3 -> 5 -> 9 -> 15 -> 20 -> 27
```
插入元素5时：
1. 随机生成层数=1
2. 在层0找到插入位置
3. 更新前后指针

### 3. 查找过程示例
查找元素20：
1. 从最高层开始：Head→15（15<20→继续）
2. 降层到1层：15→27（27>20→停止）
3. 降层到0层：15→20（找到）

## 基础使用示例
```go
// 创建跳表（需提供比较函数）
sl := NewSkipList[int](func(a, b int) int {
    return a - b
})

// 插入元素
sl.Insert(10)
sl.Insert(5)
sl.Insert(20)

// 查找元素
found := sl.Search(5)  // true

// 删除元素
sl.DeleteElement(10)

// 获取元素
val, _ := sl.Get(0)    // 5
```

## 注意事项
1. **非线程安全**：并发操作需要自行加锁
2. **比较器要求**：必须实现全序比较（返回-1/0/1）
3. **内存使用**：高层指针会占用额外空间
4. **适用场景**：适合读多写少的场景

## 性能特点
| 操作 | 最佳情况 | 最差情况 |
|------|---------|---------|
| 查找 | O(1)  | O(n)  |
| 插入 | O(1)  | O(n)  |
| 删除 | O(1)  | O(n)  |
```平均时间复杂度为O(log n)```
